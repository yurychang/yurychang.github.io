<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[Gatsby Starter Blog RSS Feed]]></description><link>https://blog.yury-chang.com</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 04 Feb 2022 18:59:49 GMT</lastBuildDate><item><title><![CDATA[理解 JavaScript 非同步機制的運作]]></title><description><![CDATA[Sync / Async / Event loop JS 是單線程的程式語言，所以同時間只能執行一個程式碼片段，並且按順序執行，這就稱為同步。執行程式碼的地方稱為 context stack (或稱為 call stack)，想像 JS…]]></description><link>https://blog.yury-chang.com/understand-JavaScript-async/</link><guid isPermaLink="false">https://blog.yury-chang.com/understand-JavaScript-async/</guid><pubDate>Fri, 04 Feb 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Sync / Async / Event loop&lt;/h2&gt;
&lt;p&gt;JS 是單線程的程式語言，所以同時間只能執行一個程式碼片段，並且按順序執行，這就稱為同步。執行程式碼的地方稱為 context stack (或稱為 call stack)，想像 JS 引擎把每一個程式碼片段轉換成 execution context 物件，執行時放入 context stack 最上方，執行完畢則移出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/6ef50c46e1361d8368162150a8a1050d/call-stack-demo.gif&quot; alt=&quot;call-stack-demo.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;但在實際的應用場景當中，如果有個工作需要占用很多時間就會卡住整個 JS 引擎，造成阻塞，無法執行後續的程式，於是 JS 就有了非同步的概念。&lt;/p&gt;
&lt;p&gt;假設我們呼叫 setTimeout 並傳入 callback，此時 callback 並不會馬上被執行，JS 引擎會繼續執行後續的程式，這樣的情況就被稱為非同步。&lt;/p&gt;
&lt;p&gt;而等到瀏覽器計時時間到，callback 就會被排進 task queue，此時就輪到 event loop 登場了，event loop 會不斷的檢查，等到 context stack 淨空之後才從 task queue 取出 task 放入 context stack 中執行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/b86688215a89a91e6ebfabb166284eda/settimeout-async-demo.gif&quot; alt=&quot;settimeout-async-demo.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;常見的非同步有瀏覽器事件、setTimeout、promise、AJAX…，但實際上在這之中還可以根據執行優先順序區分出兩種類別，micro task 和 task。&lt;/p&gt;
&lt;h2&gt;Microtasks vs Tasks&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;timeout&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;promise&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// console.log&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// promise&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// timeout&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果只看觸發順序，會覺得 timeout 應該先 log 出來，但實際上卻正好相反，這是因為 task 分成 microtask 和 task (或稱為 macrotask 以避免混淆) 兩種。&lt;/p&gt;
&lt;p&gt;Promise、MutationObserver 屬於 microtask，而瀏覽器事件、setTimeout、AJAX、UI Render 則屬於 task。&lt;/p&gt;
&lt;p&gt;如同 task 會在適當的時間點被放進 task queue，microtask 則會被放進 microtask queue，而 Event loop 在發現 context stack 清空後會優先檢查 microtask queue，如果存在 microtask 則把 microtask 放進 context stack，直到 microtask queue 也清空，接著才會檢查 task queue 並重複上述的流程。&lt;/p&gt;
&lt;p&gt;這就是上述的範例 promise 會先印出來的原因，執行步驟如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;執行 setTimeout&lt;/li&gt;
&lt;li&gt;setTimeout 時間為 0，所以 setTimeout cb 會立即被放入 task queue&lt;/li&gt;
&lt;li&gt;使用 Promise.resolve 建立 Promise&lt;/li&gt;
&lt;li&gt;Promise cb 被放入 microtask queue&lt;/li&gt;
&lt;li&gt;Event loop 確認 context stack 清空，檢查 microtask queue，並將 Promise cb 放入 context stack&lt;/li&gt;
&lt;li&gt;執行 Promise cb&lt;/li&gt;
&lt;li&gt;Event loop 確認 context stack 清空，確認 microtask queue 也清空，將 setTimeout cb 放入 context stack&lt;/li&gt;
&lt;li&gt;執行 setTimeout cb&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;p&gt;ECMAScript / 9.4 Jobs and Host Operations to Enqueue Jobs&lt;br&gt;
&lt;a href=&quot;https://html.spec.whatwg.org/multipage/webappapis.html#event-loops&quot;&gt;HTML.SPEC event-loops&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html&quot;&gt;[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D&quot;&gt;loupe&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[空白? 被 &nbsp; 雷到的經驗]]></title><description><![CDATA[最近自己做了一個打字效果，用著用著沒發現什問題，直到有一次把套用了效果的中文句子換成英文，卻赫然發現文字不會換行，像火車一樣直直的衝破螢幕去了。 當下第一反應是 CSS 忘記設定文字段行了，檢查  …正常，再加上  …沒用！而且 MDN 上還寫到   deprecated…]]></description><link>https://blog.yury-chang.com/trouble-with-nbsp-space/</link><guid isPermaLink="false">https://blog.yury-chang.com/trouble-with-nbsp-space/</guid><pubDate>Wed, 02 Feb 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最近自己做了一個打字效果，用著用著沒發現什問題，直到有一次把套用了效果的中文句子換成英文，卻赫然發現文字不會換行，像火車一樣直直的衝破螢幕去了。&lt;/p&gt;
&lt;p&gt;當下第一反應是 CSS 忘記設定文字段行了，檢查 &lt;code class=&quot;language-text&quot;&gt;white-space&lt;/code&gt; …正常，再加上 &lt;code class=&quot;language-text&quot;&gt;word-break: break-word;&lt;/code&gt; …沒用！而且 MDN 上還寫到 &lt;code class=&quot;language-text&quot;&gt;break-word&lt;/code&gt;  deprecated 😂。&lt;br&gt;
當下心一橫，蠻幹也好，我就是要換行！搜尋了一下發現有 &lt;code class=&quot;language-text&quot;&gt;overflow-wrap: break-word;&lt;/code&gt;，加上後果然可以換行了！但也直接斷在了英文單字中間拉。&lt;/p&gt;
&lt;p&gt;冷靜下來重新檢查了一下 CSS 文字換行的相關屬性，推測並不是 CSS 的問題。這時元凶已經指向了我自己寫的打字效果。&lt;br&gt;
打字效果的作法是用 JS 取出元素內的字串並分解為字元，再一個個填回原本的元素中，營造出打字的感覺。有什麼跟換行有關的東西嗎？Dev tool 上一個地方立刻吸引了我的注意。&lt;br&gt;
為了避免空白被合併，句子中所有的空白都被轉換成 &lt;code class=&quot;language-text&quot;&gt;&amp;amp;nbsp;&lt;/code&gt; 了。&lt;br&gt;
趕緊查了一下 &lt;code class=&quot;language-text&quot;&gt;&amp;amp;nbsp;&lt;/code&gt; 的資料，&lt;strong&gt;原來 &lt;code class=&quot;language-text&quot;&gt;&amp;amp;nbsp;&lt;/code&gt; 除了可以代替空白，同時還有阻止文字換行的效果阿！nbsp 就是 non-breaking-space 的縮寫。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;難怪 GSAP text plugin 要把空白轉換做成選項，原來是有這一層原因阿。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;參考資料：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3schools.com/html/html_entities.asp&quot;&gt;HTML Entities&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;http://hklifenote.blogspot.com/2014/12/blog-post.html&quot;&gt;&amp;#x26;#32與&amp;#x26;nbsp，換行空格與不換行空格&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://pymaster.tw/posts/448998-weekend-long-knowledge-no-wrap-blanks/&quot;&gt;週末長知識: 不換行空格&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap&quot;&gt;overflow-wrap - CSS（层叠样式表） | MDN&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>