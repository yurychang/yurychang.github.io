{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/understand-JavaScript-async/",
    "result": {"data":{"site":{"siteMetadata":{"title":"程式學習筆記"}},"markdownRemark":{"id":"6d399a72-93bc-5dce-b1c2-c851dd2e711a","excerpt":"Sync / Async / Event loop JS 是單線程的程式語言，所以同時間只能執行一個程式碼片段，並且按順序執行，這就稱為同步。執行程式碼的地方稱為 context stack (或稱為 call stack)，想像 JS 引擎把每一個程式碼片段轉換成 execution context…","html":"<h2>Sync / Async / Event loop</h2>\n<p>JS 是單線程的程式語言，所以同時間只能執行一個程式碼片段，並且按順序執行，這就稱為同步。執行程式碼的地方稱為 context stack (或稱為 call stack)，想像 JS 引擎把每一個程式碼片段轉換成 execution context 物件，執行時放入 context stack 最上方，執行完畢則移出。</p>\n<p><img src=\"/6ef50c46e1361d8368162150a8a1050d/call-stack-demo.gif\" alt=\"call-stack-demo.gif\"></p>\n<p>但在實際的應用場景當中，如果有個工作需要占用很多時間就會卡住整個 JS 引擎，造成阻塞，無法執行後續的程式，於是 JS 就有了非同步的概念。</p>\n<p>假設我們呼叫 setTimeout 並傳入 callback，此時 callback 並不會馬上被執行，JS 引擎會繼續執行後續的程式，這樣的情況就被稱為非同步。</p>\n<p>而等到瀏覽器計時時間到，callback 就會被排進 task queue，此時就輪到 event loop 登場了，event loop 會不斷的檢查，等到 context stack 淨空之後才從 task queue 取出 task 放入 context stack 中執行。</p>\n<p><img src=\"/b86688215a89a91e6ebfabb166284eda/settimeout-async-demo.gif\" alt=\"settimeout-async-demo.gif\"></p>\n<p>常見的非同步有瀏覽器事件、setTimeout、promise、AJAX…，但實際上在這之中還可以根據執行優先順序區分出兩種類別，micro task 和 task。</p>\n<h2>Microtasks vs Tasks</h2>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// console.log</span>\n<span class=\"token comment\">// promise</span>\n<span class=\"token comment\">// timeout</span></code></pre></div>\n<p>如果只看觸發順序，會覺得 timeout 應該先 log 出來，但實際上卻正好相反，這是因為 task 分成 microtask 和 task (或稱為 macrotask 以避免混淆) 兩種。</p>\n<p>Promise、MutationObserver 屬於 microtask，而瀏覽器事件、setTimeout、AJAX、UI Render 則屬於 task。</p>\n<p>如同 task 會在適當的時間點被放進 task queue，microtask 則會被放進 microtask queue，而 Event loop 在發現 context stack 清空後會優先檢查 microtask queue，如果存在 microtask 則把 microtask 放進 context stack，直到 microtask queue 也清空，接著才會檢查 task queue 並重複上述的流程。</p>\n<p>這就是上述的範例 promise 會先印出來的原因，執行步驟如下：</p>\n<ol>\n<li>執行 setTimeout</li>\n<li>setTimeout 時間為 0，所以 setTimeout cb 會立即被放入 task queue</li>\n<li>使用 Promise.resolve 建立 Promise</li>\n<li>Promise cb 被放入 microtask queue</li>\n<li>Event loop 確認 context stack 清空，檢查 microtask queue，並將 Promise cb 放入 context stack</li>\n<li>執行 Promise cb</li>\n<li>Event loop 確認 context stack 清空，確認 microtask queue 也清空，將 setTimeout cb 放入 context stack</li>\n<li>執行 setTimeout cb</li>\n</ol>\n<h2>參考資料</h2>\n<p>ECMAScript / 9.4 Jobs and Host Operations to Enqueue Jobs<br>\n<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops\">HTML.SPEC event-loops</a><br>\n<a href=\"https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html\">[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式</a><br>\n<a href=\"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\">loupe</a></p>","frontmatter":{"title":"理解 JavaScript 非同步機制的運作","date":"February 04, 2022","description":null}},"previous":{"fields":{"slug":"/trouble-with-nbsp-space/"},"frontmatter":{"title":"空白? 被 &nbsp; 雷到的經驗"}},"next":null},"pageContext":{"id":"6d399a72-93bc-5dce-b1c2-c851dd2e711a","previousPostId":"611d0049-33b3-51bb-8e6b-353fb25e3f59","nextPostId":null}},
    "staticQueryHashes": ["3000541721","3257411868"]}